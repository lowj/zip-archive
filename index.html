<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zip - Dynamic Grid</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #f8f9fa;
            --grid-bg: #ffffff;
            --grid-border: #e0e0e0;
            --cell-border: #ebebeb;
            --number-bg: #1a1a1a;
            --number-text: #ffffff;
            --path-start: #4a90d9;
            --path-end: #7c5ce7;
            --path-thickness: 16px; 
            --success: #00c853;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            user-select: none;
            -webkit-user-select: none;
        }

        .page-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            width: 100%;
            max-width: 600px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        header {
            text-align: center;
        }

        h1 {
            font-family: 'Space Mono', monospace;
            font-size: 2.5rem;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #666;
            font-size: 0.95rem;
            margin-top: 4px;
        }

        .grid-wrapper {
            background: var(--grid-bg);
            border-radius: 16px;
            padding: 12px;
            box-shadow: 
                0 4px 6px rgba(0, 0, 0, 0.04),
                0 10px 40px rgba(0, 0, 0, 0.08);
            /* Allow scrolling if grid is huge on small screen */
            overflow: auto;
            max-width: 100%; 
        }

        .grid {
            display: grid;
            /* grid-template-columns is now set via JS */
            gap: 0;
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            /* overflow: hidden; removed to ensure borders render cleanly */
            position: relative;
            margin: 0 auto;
        }

        .cell {
            width: 52px;
            height: 52px;
            border: 1px solid var(--cell-border);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        /* --- SNAKE STYLING --- */
        .cell.filled { background: transparent; }
        .cell.path, .cell.current { background: transparent; box-shadow: none; }

        .cell.path::before, .cell.current::before {
            content: '';
            position: absolute;
            width: var(--path-thickness);
            height: var(--path-thickness);
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
            border-radius: 50%;
            z-index: 5;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .cell.current::before {
            transform: translate(-50%, -50%) scale(1.4);
            box-shadow: 0 0 10px rgba(124, 92, 231, 0.5);
            z-index: 6;
        }

        .connector {
            position: absolute;
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
            z-index: 4;
            pointer-events: none;
        }

        .connector.horizontal {
            height: var(--path-thickness);
            width: calc(50% + 2px);
            top: 50%;
            margin-top: calc(var(--path-thickness) / -2);
        }

        .connector.vertical {
            width: var(--path-thickness);
            height: calc(50% + 2px);
            left: 50%;
            margin-left: calc(var(--path-thickness) / -2);
        }

        .connector.right { left: 50%; }
        .connector.left { right: 50%; left: auto; }
        .connector.down { top: 50%; }
        .connector.up { bottom: 50%; top: auto; }
        /* ------------------- */

        .cell.wall-top { border-top: 3px solid #1a1a1a; }
        .cell.wall-bottom { border-bottom: 3px solid #1a1a1a; }
        .cell.wall-left { border-left: 3px solid #1a1a1a; }
        .cell.wall-right { border-right: 3px solid #1a1a1a; }

        .number {
            width: 36px;
            height: 36px;
            background: var(--number-bg);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--number-text);
            font-family: 'DM Sans', sans-serif;
            font-weight: 700;
            font-size: 19px;
            z-index: 10;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }

        .number.active {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .number.completed {
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
        }

        .controls {
            display: flex;
            gap: 12px;
        }

        button {
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            font-size: 1rem;
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-reset {
            background: white;
            color: #333;
            border: 2px solid var(--grid-border);
        }

        .btn-reset:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }

        .btn-new {
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
            color: white;
        }

        .btn-new:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 217, 0.35);
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .message h2 {
            font-family: 'Space Mono', monospace;
            font-size: 2rem;
            color: var(--success);
            margin-bottom: 8px;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 99;
        }

        .overlay.show { opacity: 1; pointer-events: auto; }

        .instructions {
            max-width: 400px;
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* --- MODE TOGGLE & LAYOUT --- */
        .mode-toggle {
            display: flex;
            background: white;
            border-radius: 12px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            margin-bottom: 8px;
        }

        .mode-btn {
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            font-size: 0.9rem;
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            color: #666;
            transition: all 0.2s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--path-start), var(--path-end));
            color: white;
        }

        .mode-btn:not(.active):hover { background: #f5f5f5; }

        .game-container:not(.active),
        .creator-container:not(.active),
        .archive-container:not(.active) {
            display: none !important;
        }

        .creator-container.active, 
        .archive-container.active {
            display: flex;
        }

        /* --- CREATOR STYLES --- */
        .creator-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 440px;
        }
        
        /* New styling for size inputs */
        .size-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        .size-input {
            width: 50px;
            padding: 8px;
            border: 2px solid var(--grid-border);
            border-radius: 6px;
            font-family: 'Space Mono', monospace;
            text-align: center;
            font-size: 1rem;
        }
        .size-separator { font-weight: bold; color: #888; }
        .btn-set-size { 
            padding: 8px 16px; 
            font-size: 0.9rem;
            background: var(--number-bg);
            color: white;
        }

        .creator-container {
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .creator-cell {
            width: 52px;
            height: 52px;
            border: 1px solid var(--cell-border);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .creator-cell.wall-top { border-top: 3px solid #1a1a1a; }
        .creator-cell.wall-bottom { border-bottom: 3px solid #1a1a1a; }
        .creator-cell.wall-left { border-left: 3px solid #1a1a1a; }
        .creator-cell.wall-right { border-right: 3px solid #1a1a1a; }

        .creator-cell .edge-zone { position: absolute; z-index: 5; }
        .creator-cell .edge-zone.top { top: 0; left: 8px; right: 8px; height: 8px; cursor: n-resize; }
        .creator-cell .edge-zone.bottom { bottom: 0; left: 8px; right: 8px; height: 8px; cursor: s-resize; }
        .creator-cell .edge-zone.left { left: 0; top: 8px; bottom: 8px; width: 8px; cursor: w-resize; }
        .creator-cell .edge-zone.right { right: 0; top: 8px; bottom: 8px; width: 8px; cursor: e-resize; }
        .creator-cell .edge-zone:hover { background: rgba(26, 26, 26, 0.3); }

        .output-area { width: 100%; max-width: 500px; }
        .output-area label { display: block; font-weight: 500; margin-bottom: 8px; color: #333; }
        .output-area textarea {
            width: 100%; height: 150px; font-family: 'Space Mono', monospace;
            font-size: 0.8rem; padding: 12px; border: 2px solid var(--grid-border);
            border-radius: 8px; resize: vertical;
        }
        .output-area textarea:focus { outline: none; border-color: var(--path-start); }

        .btn-clear { background: #ff6b6b; color: white; }
        .btn-clear:hover { background: #ee5a5a; }
        .btn-copy { background: var(--number-bg); color: white; }
        .btn-copy:hover { background: #333; }
        .btn-test { background: linear-gradient(135deg, var(--path-start), var(--path-end)); color: white; }

        .creator-instructions {
            max-width: 400px;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* --- ARCHIVE STYLES --- */
        .archive-container {
            width: 100%;
            flex-direction: column;
            gap: 20px;
        }

        .archive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 12px;
            width: 100%;
            background: var(--grid-bg);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid var(--grid-border);
        }

        .level-card {
            aspect-ratio: 1;
            background: #f0f0f0;
            border: 2px solid transparent;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            font-size: 1.1rem;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .level-card:hover {
            background: white;
            border-color: var(--path-start);
            box-shadow: 0 4px 12px rgba(74, 144, 217, 0.2);
            color: var(--path-start);
            transform: translateY(-2px);
        }

        @media (max-width: 500px) {
            .cell, .creator-cell { width: 42px; height: 42px; }
            .number { width: 30px; height: 30px; font-size: 12px; }
            h1 { font-size: 2rem; }
            .controls { flex-direction: column; width: 100%; }
            button { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header>
            <h1>ZIP</h1>
            <p class="subtitle">Connect the numbers, fill the grid</p>
        </header>

        <div class="mode-toggle">
            <button class="mode-btn active" onclick="setMode('play')">Play</button>
            <button class="mode-btn" onclick="setMode('create')">Create</button>
            <button class="mode-btn" onclick="setMode('archive')">Archive</button>
        </div>

        <div class="game-container active" id="game-mode">
            <div class="grid-wrapper">
                <div class="grid" id="grid"></div>
            </div>

            <div class="controls">
                <button class="btn-reset" onclick="resetPuzzle()">Reset</button>
                <button class="btn-new" onclick="loadNextBuiltIn()">Next Level</button>
            </div>

            <p class="instructions">
                Draw a path starting from 1, visiting each number in order. 
                Fill every cell on the grid to complete the puzzle.
            </p>
        </div>

        <div class="creator-container" id="create-mode">
            
            <div class="size-controls">
                <label>Grid Size:</label>
                <input type="number" id="create-width" class="size-input" value="8" min="3" max="15">
                <span class="size-separator">Ã—</span>
                <input type="number" id="create-height" class="size-input" value="8" min="3" max="15">
                <button class="btn-set-size" onclick="resizeCreator()">Set</button>
            </div>

            <div class="grid-wrapper">
                <div class="grid" id="creator-grid"></div>
            </div>

            <div class="creator-controls">
                <button class="btn-clear" onclick="clearCreator()">Clear All</button>
                <button class="btn-reset" onclick="undoLastNumber()">Undo Number</button>
                <button class="btn-copy" onclick="copyOutput()">Copy JSON</button>
                <button class="btn-test" onclick="testLevel()">Test Level</button>
            </div>

            <div class="output-area">
                <label>Level JSON Output:</label>
                <textarea id="level-output" readonly placeholder="Click cells to add numbers, click edges to add walls..."></textarea>
            </div>

            <p class="creator-instructions">
                <strong>Click center</strong> to place number.<br>
                <strong>Click edge</strong> to toggle wall.<br>
                <strong>Right-click number</strong> to remove.
            </p>
        </div>

        <div class="archive-container" id="archive-mode">
            <div class="archive-grid" id="archive-grid">
                </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="message" id="message">
        <h2>ðŸŽ‰ Complete!</h2>
        <p>You solved the puzzle!</p>
        <button class="btn-new" onclick="loadNextBuiltIn(); hideMessage();">Next Level</button>
    </div>

    <script>
        // Built-in puzzles (Fallbacks)
        const builtInPuzzles = [
            {
                width: 8, height: 8,
                numbers: [
                    {n: 1, r: 2, c: 6}, {n: 2, r: 2, c: 5}, {n: 3, r: 5, c: 3},
                    {n: 4, r: 2, c: 4}, {n: 5, r: 2, c: 2}, {n: 6, r: 1, c: 2},
                    {n: 7, r: 1, c: 4}, {n: 8, r: 1, c: 6}, {n: 9, r: 3, c: 6},
                    {n: 10, r: 5, c: 7}, {n: 11, r: 6, c: 7}, {n: 12, r: 7, c: 7},
                    {n: 13, r: 6, c: 6}, {n: 14, r: 5, c: 5}, {n: 15, r: 6, c: 5},
                    {n: 16, r: 6, c: 3}, {n: 17, r: 7, c: 3}, {n: 18, r: 5, c: 1},
                    {n: 19, r: 2, c: 0}, {n: 20, r: 1, c: 0}, {n: 21, r: 2, c: 1},
                    {n: 22, r: 3, c: 2}, {n: 23, r: 6, c: 2}, {n: 24, r: 6, c: 1}
                ],
                walls: []
            },
            {
                width: 8, height: 8,
                numbers: [
                    {n: 1, r: 0, c: 0}, {n: 2, r: 0, c: 3}, {n: 3, r: 2, c: 3},
                    {n: 4, r: 2, c: 0}, {n: 5, r: 4, c: 0}, {n: 6, r: 4, c: 3},
                    {n: 7, r: 6, c: 3}, {n: 8, r: 6, c: 0}, {n: 9, r: 7, c: 4},
                    {n: 10, r: 5, c: 5}, {n: 11, r: 3, c: 5}, {n: 12, r: 1, c: 5},
                    {n: 13, r: 0, c: 7}, {n: 14, r: 3, c: 7}, {n: 15, r: 5, c: 7},
                    {n: 16, r: 7, c: 7}
                ],
                walls: [
                    {r: 1, c: 3, side: 'bottom'}, {r: 2, c: 3, side: 'top'},
                    {r: 3, c: 1, side: 'right'}, {r: 3, c: 2, side: 'left'},
                    {r: 5, c: 4, side: 'bottom'}, {r: 6, c: 4, side: 'top'}
                ]
            }
        ];

        // Global State
        let currentLevelData = null; 
        let currentBuiltInIndex = 0;
        let grid = [];
        let path = [];
        let isDragging = false;
        let totalCells = 64;
        let maxNumber = 0;
        
        // Dimensions
        let currentRows = 8;
        let currentCols = 8;

        // --- GAME LOGIC ---

        function initGrid(rows, cols) {
            currentRows = rows;
            currentCols = cols;
            totalCells = rows * cols;
            
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            // Dynamic grid layout
            gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            grid = [];
            
            for (let r = 0; r < rows; r++) {
                grid[r] = [];
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gridEl.appendChild(cell);
                    grid[r][c] = {
                        element: cell,
                        number: null,
                        inPath: false,
                        walls: []
                    };
                }
            }
        }

        function loadLevelData(puzzleData) {
            currentLevelData = puzzleData;
            // Default to 8x8 if not specified (backward compatibility)
            const w = puzzleData.width || 8;
            const h = puzzleData.height || 8;
            
            initGrid(h, w);
            path = [];
            
            maxNumber = Math.max(...puzzleData.numbers.map(p => p.n));
            
            // Add numbers
            puzzleData.numbers.forEach(({n, r, c}) => {
                // Bounds check just in case
                if (r < h && c < w) {
                    const cell = grid[r][c];
                    const numberEl = document.createElement('div');
                    numberEl.className = 'number';
                    numberEl.textContent = n;
                    cell.element.appendChild(numberEl);
                    cell.number = n;
                    cell.numberEl = numberEl;
                }
            });

            // Add walls
            if (puzzleData.walls) {
                puzzleData.walls.forEach(({r, c, side}) => {
                    if (r < h && c < w) {
                        const cell = grid[r][c];
                        cell.element.classList.add(`wall-${side}`);
                        if (!cell.walls) cell.walls = [];
                        cell.walls.push(side);
                    }
                });
            }

            updateStatus();
            setupEventListeners();
        }

        function loadNextBuiltIn() {
            currentBuiltInIndex = (currentBuiltInIndex + 1) % builtInPuzzles.length;
            loadLevelData(builtInPuzzles[currentBuiltInIndex]);
            hideMessage();
        }

        function resetPuzzle() {
            if (currentLevelData) {
                loadLevelData(currentLevelData);
            }
        }

        function setupEventListeners() {
            const gridEl = document.getElementById('grid');
            const newGridEl = gridEl.cloneNode(true);
            gridEl.parentNode.replaceChild(newGridEl, gridEl);
            
            // Re-hydrate state from DOM after clone
            const cells = newGridEl.querySelectorAll('.cell');
            cells.forEach((cell, idx) => {
                const r = Math.floor(idx / currentCols);
                const c = idx % currentCols;
                grid[r][c].element = cell;
                const numberEl = cell.querySelector('.number');
                if (numberEl) grid[r][c].numberEl = numberEl;
                
                grid[r][c].walls = [];
                if (cell.classList.contains('wall-top')) grid[r][c].walls.push('top');
                if (cell.classList.contains('wall-bottom')) grid[r][c].walls.push('bottom');
                if (cell.classList.contains('wall-left')) grid[r][c].walls.push('left');
                if (cell.classList.contains('wall-right')) grid[r][c].walls.push('right');
            });

            newGridEl.addEventListener('mousedown', handleStart);
            newGridEl.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            newGridEl.addEventListener('touchstart', handleStart, {passive: false});
            newGridEl.addEventListener('touchmove', handleMove, {passive: false});
            document.addEventListener('touchend', handleEnd);
        }

        function getCellFromEvent(e) {
            let target = e.touches ? document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY) : e.target;
            while (target && !target.classList.contains('cell')) {
                target = target.parentElement;
            }
            if (!target || !target.dataset.row) return null;
            const r = parseInt(target.dataset.row);
            const c = parseInt(target.dataset.col);
            return {r, c, cell: grid[r][c]};
        }

        function handleStart(e) {
            e.preventDefault();
            const data = getCellFromEvent(e);
            if (!data) return;
            const {r, c, cell} = data;
            
            if (path.length === 0) {
                if (cell.number === 1) startPath(r, c);
            } else {
                const head = path[path.length - 1];
                if (head.r === r && head.c === c) isDragging = true;
            }
        }

        function handleMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const data = getCellFromEvent(e);
            if (!data) return;
            extendPath(data.r, data.c);
        }

        function handleEnd() { isDragging = false; }

        function startPath(r, c) {
            path = [{r, c}];
            isDragging = true;
            updateGridDisplay();
        }

        function isAdjacent(r1, c1, r2, c2) {
            const dr = Math.abs(r1 - r2);
            const dc = Math.abs(c1 - c2);
            if (!((dr === 1 && dc === 0) || (dr === 0 && dc === 1))) return false;
            
            const from = grid[r1][c1];
            const to = grid[r2][c2];
            
            if (r2 < r1 && (from.walls.includes('top') || to.walls.includes('bottom'))) return false;
            if (r2 > r1 && (from.walls.includes('bottom') || to.walls.includes('top'))) return false;
            if (c2 < c1 && (from.walls.includes('left') || to.walls.includes('right'))) return false;
            if (c2 > c1 && (from.walls.includes('right') || to.walls.includes('left'))) return false;
            
            return true;
        }

        function extendPath(r, c) {
            if (path.length === 0) return;
            const head = path[path.length - 1];
            if (head.r === r && head.c === c) return;
            
            if (!isAdjacent(head.r, head.c, r, c)) return;
            
            const existingIdx = path.findIndex(p => p.r === r && p.c === c);
            if (existingIdx !== -1) {
                // Check if we are backtracking (undoing the last step)
                // path.length - 2 is the index of the second to last element
                if (existingIdx === path.length - 2) {
                    path.pop();
                    updateGridDisplay();
                    return;
                }
                
                // If it's not a backtrack (e.g. crossing an earlier part of the path), 
                // do nothing to prevent accidental deletions.
                return;
            }
            
            // --- REMOVED STRICT NUMBER CHECK HERE ---
            // Previously, there was code here checking if cell.number === lastNumber + 1.
            // By removing it, we allow out-of-order traversal.
            
            path.push({r, c});
            updateGridDisplay();
            
            if (path.length === totalCells) {
                const numbersInPath = path.map(p => grid[p.r][p.c].number).filter(n => n !== null);
                if (numbersInPath.length === maxNumber) {
                    let inOrder = true;
                    for (let i = 0; i < numbersInPath.length - 1; i++) {
                        if (numbersInPath[i] >= numbersInPath[i + 1]) { inOrder = false; break; }
                    }
                    if (inOrder) setTimeout(showWinMessage, 300);
                }
            }
        }

        function getDirection(from, to) {
            if (to.r < from.r) return 'up';
            if (to.r > from.r) return 'down';
            if (to.c < from.c) return 'left';
            if (to.c > from.c) return 'right';
            return null;
        }

        function opposite(dir) {
            return {up: 'down', down: 'up', left: 'right', right: 'left'}[dir];
        }

        function updateGridDisplay() {
            for (let r = 0; r < currentRows; r++) {
                for (let c = 0; c < currentCols; c++) {
                    const cell = grid[r][c];
                    cell.element.classList.remove('filled', 'path', 'current');
                    cell.element.querySelectorAll('.connector').forEach(el => el.remove());
                    if (cell.numberEl) cell.numberEl.classList.remove('active', 'completed');
                }
            }
            for (let i = 0; i < path.length; i++) {
                const {r, c} = path[i];
                const cell = grid[r][c];
                
                if (i === path.length - 1) {
                    cell.element.classList.add('current');
                    if (cell.numberEl) cell.numberEl.classList.add('active');
                } else {
                    cell.element.classList.add('path');
                    if (cell.numberEl) cell.numberEl.classList.add('completed');
                }
                
                if (i > 0) {
                    const prev = path[i - 1];
                    const dir = getDirection(prev, path[i]);
                    addConnector(prev.r, prev.c, dir);
                    addConnector(r, c, opposite(dir));
                }
            }
            updateStatus();
        }

        function addConnector(r, c, direction) {
            const connector = document.createElement('div');
            connector.className = `connector ${['left','right'].includes(direction) ? 'horizontal' : 'vertical'} ${direction}`;
            grid[r][c].element.appendChild(connector);
        }

        function updateStatus() {
        }

        function showWinMessage() {
            document.getElementById('overlay').classList.add('show');
            document.getElementById('message').classList.add('show');
        }

        function hideMessage() {
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('message').classList.remove('show');
        }

        // --- MODE MANAGEMENT ---
        function setMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[onclick="setMode('${mode}')"]`).classList.add('active');
            
            document.getElementById('game-mode').classList.toggle('active', mode === 'play');
            document.getElementById('create-mode').classList.toggle('active', mode === 'create');
            document.getElementById('archive-mode').classList.toggle('active', mode === 'archive');
            
            if (mode === 'create') {
                // Initialize creator grid with current settings
                const w = parseInt(document.getElementById('create-width').value);
                const h = parseInt(document.getElementById('create-height').value);
                initCreatorGrid(h, w);
            }
            if (mode === 'archive') renderArchive();
        }

        // --- CREATOR LOGIC ---
        let creatorGrid = [], creatorNumbers = [], creatorWalls = [], nextCreatorNumber = 1;
        let creatorRows = 8, creatorCols = 8;

        function resizeCreator() {
            const w = parseInt(document.getElementById('create-width').value);
            const h = parseInt(document.getElementById('create-height').value);
            if(w < 3 || h < 3 || w > 15 || h > 15) {
                alert("Size must be between 3x3 and 15x15");
                return;
            }
            // Clear current data when resizing
            if(confirm("Changing size will clear the current layout. Continue?")) {
                clearCreator();
                initCreatorGrid(h, w);
            }
        }

        function initCreatorGrid(rows, cols) {
            creatorRows = rows;
            creatorCols = cols;
            
            const gridEl = document.getElementById('creator-grid');
            gridEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            creatorGrid = [];
            for (let r = 0; r < rows; r++) {
                creatorGrid[r] = [];
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'creator-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    ['top', 'bottom', 'left', 'right'].forEach(side => {
                        const edge = document.createElement('div');
                        edge.className = `edge-zone ${side}`;
                        edge.onclick = (e) => { e.stopPropagation(); toggleWall(r, c, side); };
                        cell.appendChild(edge);
                    });
                    
                    cell.onclick = (e) => { if (!e.target.classList.contains('edge-zone')) placeNumber(r, c); };
                    cell.oncontextmenu = (e) => { e.preventDefault(); removeNumber(r, c); };
                    
                    gridEl.appendChild(cell);
                    creatorGrid[r][c] = { element: cell, number: null, numberEl: null, walls: [] };
                }
            }
            // updateOutput called inside to set initial JSON
            updateOutput();
        }

        function placeNumber(r, c) {
            const cell = creatorGrid[r][c];
            if (cell.number !== null) return;
            
            const numberEl = document.createElement('div');
            numberEl.className = 'number';
            numberEl.textContent = nextCreatorNumber;
            cell.element.appendChild(numberEl);
            cell.number = nextCreatorNumber;
            cell.numberEl = numberEl;
            creatorNumbers.push({n: nextCreatorNumber, r, c});
            nextCreatorNumber++;
            updateOutput();
        }

        function removeNumber(r, c) {
            const cell = creatorGrid[r][c];
            if (cell.number === null) return;
            const removed = cell.number;
            if (cell.numberEl) cell.numberEl.remove();
            cell.number = null;
            cell.numberEl = null;
            creatorNumbers = creatorNumbers.filter(n => !(n.r === r && n.c === c));
            creatorNumbers.forEach(n => {
                if (n.n > removed) {
                    n.n--;
                    creatorGrid[n.r][n.c].number = n.n;
                    if (creatorGrid[n.r][n.c].numberEl) creatorGrid[n.r][n.c].numberEl.textContent = n.n;
                }
            });
            nextCreatorNumber--;
            updateOutput();
        }

        function undoLastNumber() {
            if (creatorNumbers.length > 0) {
                const last = creatorNumbers[creatorNumbers.length - 1];
                removeNumber(last.r, last.c);
            }
        }

        function toggleWall(r, c, side) {
            const cell = creatorGrid[r][c];
            const idx = cell.walls.indexOf(side);
            if (idx === -1) {
                cell.walls.push(side);
                cell.element.classList.add(`wall-${side}`);
                creatorWalls.push({r, c, side});
                // Add adjacent
                const adj = getAdj(r, c, side);
                if (adj) {
                    const opp = opposite(side);
                    const ac = creatorGrid[adj.r][adj.c];
                    if (!ac.walls.includes(opp)) {
                        ac.walls.push(opp);
                        ac.element.classList.add(`wall-${opp}`);
                        creatorWalls.push({r: adj.r, c: adj.c, side: opp});
                    }
                }
            } else {
                cell.walls.splice(idx, 1);
                cell.element.classList.remove(`wall-${side}`);
                creatorWalls = creatorWalls.filter(w => !(w.r === r && w.c === c && w.side === side));
                // Remove adjacent
                const adj = getAdj(r, c, side);
                if (adj) {
                    const opp = opposite(side);
                    const ac = creatorGrid[adj.r][adj.c];
                    const aidx = ac.walls.indexOf(opp);
                    if (aidx !== -1) {
                        ac.walls.splice(aidx, 1);
                        ac.element.classList.remove(`wall-${opp}`);
                        creatorWalls = creatorWalls.filter(w => !(w.r === adj.r && w.c === adj.c && w.side === opp));
                    }
                }
            }
            updateOutput();
        }

        function getAdj(r, c, side) {
            if (side === 'top' && r > 0) return {r: r-1, c};
            if (side === 'bottom' && r < creatorRows - 1) return {r: r+1, c};
            if (side === 'left' && c > 0) return {r, c: c-1};
            if (side === 'right' && c < creatorCols - 1) return {r, c: c+1};
            return null;
        }

        function updateOutput() {
            const out = {
                width: creatorCols,
                height: creatorRows,
                numbers: creatorNumbers.map(n => ({n: n.n, r: n.r, c: n.c})),
                walls: creatorWalls.map(w => ({r: w.r, c: w.c, side: w.side}))
            };
            document.getElementById('level-output').value = JSON.stringify(out, null, 2);
        }

        function clearCreator() {
            creatorNumbers = []; creatorWalls = []; nextCreatorNumber = 1;
            // Re-init with currently selected input values
            const w = parseInt(document.getElementById('create-width').value);
            const h = parseInt(document.getElementById('create-height').value);
            initCreatorGrid(h, w);
        }

        function renderCreatorState() {
            // Note: This function assumes the grid dimensions haven't changed externally
            // or that creatorGrid is already init to correct size.
            creatorNumbers.forEach(({n, r, c}) => {
                if(r < creatorRows && c < creatorCols) {
                    const cell = creatorGrid[r][c];
                    const nel = document.createElement('div');
                    nel.className = 'number'; nel.textContent = n;
                    cell.element.appendChild(nel);
                    cell.number = n; cell.numberEl = nel;
                }
            });
            creatorWalls.forEach(({r, c, side}) => {
                if(r < creatorRows && c < creatorCols) {
                    const cell = creatorGrid[r][c];
                    if (!cell.walls.includes(side)) cell.walls.push(side);
                    cell.element.classList.add(`wall-${side}`);
                }
            });
            updateOutput();
        }

        function copyOutput() {
            const txt = document.getElementById('level-output');
            txt.select();
            document.execCommand('copy');
        }

        function testLevel() {
            if (creatorNumbers.length < 2) { alert('Need at least 2 numbers'); return; }
            const testPuz = {
                width: creatorCols,
                height: creatorRows,
                numbers: creatorNumbers.map(n => ({n: n.n, r: n.r, c: n.c})),
                walls: creatorWalls.map(w => ({r: w.r, c: w.c, side: w.side}))
            };
            loadLevelData(testPuz);
            setMode('play');
        }

        // --- ARCHIVE LOGIC ---

        async function renderArchive() {
            const gridEl = document.getElementById('archive-grid');
            if (gridEl.children.length > 0) return; 

            gridEl.innerHTML = '<p style="text-align:center; width:100%; color:#888;">Loading...</p>';

            try {
                const response = await fetch('archive/levels.json');
                if (!response.ok) throw new Error('Could not find archive/levels.json');
                
                const levels = await response.json();
                levels.sort((a, b) => b - a);

                gridEl.innerHTML = ''; 

                if (levels.length === 0) {
                    gridEl.innerHTML = '<p style="text-align:center; width:100%; color:#888;">No levels found in levels.json</p>';
                }

                levels.forEach(levelId => {
                    const btn = document.createElement('button');
                    btn.className = 'level-card';
                    btn.textContent = levelId;
                    btn.onclick = () => fetchAndLoadLevel(levelId);
                    gridEl.appendChild(btn);
                });

            } catch (e) {
                gridEl.innerHTML = `<p style="text-align:center; width:100%; color:#d32f2f;">
                    <strong>Error:</strong> Could not load <code>archive/levels.json</code>.<br>
                    Make sure you created the file and are running on a local server.
                </p>`;
                console.error(e);
            }
        }

        async function fetchAndLoadLevel(levelId) {
            try {
                const response = await fetch(`archive/${levelId}.json`);
                if (!response.ok) throw new Error(`Level ${levelId} not found.`);
                
                const data = await response.json();
                
                loadLevelData(data);
                setMode('play');
                
            } catch (error) {
                console.error(error);
                alert(`Error loading level ${levelId}.\nCheck console for details.`);
            }
        }

        // Initialize with default
        loadLevelData(builtInPuzzles[0]);
    </script>
</body>
</html>
